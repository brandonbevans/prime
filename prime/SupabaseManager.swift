//
//  SupabaseManager.swift
//  prime
//
//  Created on 11/17/25.
//

import Combine
import Foundation
import Supabase

/// Manager class for handling all Supabase operations
@MainActor
class SupabaseManager: ObservableObject {
  let objectWillChange = ObservableObjectPublisher()
  static let shared = SupabaseManager()

  private let client: SupabaseClient

  private init() {
    print("ðŸš€ [SupabaseManager] Initializing Supabase client...")
    
    // Initialize Supabase client with configuration
    guard Config.isConfigured else {
      fatalError(
        "Supabase configuration is missing or invalid. Please update Config.swift with your Supabase project details."
      )
    }
    
    let urlString = Config.supabaseURL
    
    guard let supabaseURL = URL(string: urlString) else {
      fatalError(
        "Supabase URL is invalid: \(urlString). Please check your SUPABASE_URL configuration."
      )
    }
    
    let anonKey = Config.supabaseAnonKey

    let options = SupabaseClientOptions(
      auth: .init(
        emitLocalSessionAsInitialSession: true
      )
    )

    self.client = SupabaseClient(
      supabaseURL: supabaseURL,
      supabaseKey: anonKey,
      options: options
    )
    print("âœ… [SupabaseManager] SupabaseClient created successfully")
  }

  // MARK: - User Profile Operations

  /// Structure matching the database schema for user data
  struct UserProfile: Codable {
    let id: Int?  // BIGSERIAL primary key from database
    let userId: UUID
    let goalRecency: String?
    let primaryGoal: String
    let goalVisualization: String
    let microAction: String
    let coachingStyle: String?
    let onboardingCompleted: Bool
    let onboardingCompletedAt: Date?
    let lastCompletedStep: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case goalRecency = "goal_recency"
      case primaryGoal = "primary_goal"
      case goalVisualization = "goal_visualization"
      case microAction = "micro_action"
      case coachingStyle = "coaching_style"
      case onboardingCompleted = "onboarding_completed"
      case onboardingCompletedAt = "onboarding_completed_at"
      case lastCompletedStep = "last_completed_step"
    }
  }

  /// Save user onboarding data to Supabase
  func saveOnboardingData(
    goalRecency: GoalRecency?,
    primaryGoal: String,
    goalVisualization: String,
    microAction: String,
    coachingStyle: CoachingStyle?,
    lastCompletedStep: String? = nil
  ) async throws -> UserProfile {
    // Get the current authenticated user ID
    let userId = try await getCurrentUserId()

    // Map enum values to database-friendly strings
    let goalRecencyString = mapGoalRecencyToDatabase(goalRecency)
    let coachingStyleString = mapCoachingStyleToDatabase(coachingStyle)

    // Create user profile object
    let profile = UserProfile(
      id: nil,  // Will be auto-generated by database
      userId: userId,
      goalRecency: goalRecencyString,
      primaryGoal: primaryGoal,
      goalVisualization: goalVisualization,
      microAction: microAction,
      coachingStyle: coachingStyleString,
      onboardingCompleted: true,
      onboardingCompletedAt: Date(),
      lastCompletedStep: lastCompletedStep
    )

    // Insert or update the user profile
    do {
      print("ðŸ“¤ Sending profile to Supabase...")
      print("  - Table: user_profiles")
      print("  - User ID: \(userId)")
      print("  - Operation: UPSERT (will create or update)")

      let response: PostgrestResponse<UserProfile> =
        try await client
        .from("user_profiles")
        .upsert(profile, onConflict: "user_id")
        .select()
        .single()
        .execute()

      print("âœ… Supabase response received - profile saved/updated")
      return response.value
    } catch {
      print("âŒ Supabase error during profile save:")
      print("  - Error: \(error)")
      print("  - Type: \(type(of: error))")
      throw error
    }
  }

  /// Fetch the current user's profile
  func fetchUserProfile() async throws -> UserProfile? {
    let userId = try await getCurrentUserId()

    // Use limit(1) instead of single() to avoid throwing error when no profile exists
    let response: PostgrestResponse<[UserProfile]> =
      try await client
      .from("user_profiles")
      .select()
      .eq("user_id", value: userId.uuidString)
      .limit(1)
      .execute()

    return response.value.first
  }
  
  /// Update the user's coaching style preference
  func updateCoachingStyle(_ style: CoachingStyle) async throws {
    let userId = try await getCurrentUserId()
    let styleString = mapCoachingStyleToDatabase(style)
    
    struct CoachingStyleUpdate: Encodable {
      let coaching_style: String?
    }
    
    let update = CoachingStyleUpdate(coaching_style: styleString)
    
    try await client
      .from("user_profiles")
      .update(update)
      .eq("user_id", value: userId.uuidString)
      .execute()
    
    print("âœ… Updated coaching style to: \(style.rawValue)")
  }

  // MARK: - Goal Operations

  struct Goal: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let updatedAt: Date?
    let goalText: String
    let visualizationText: String?
    let microAction: String?
    let status: String
    let completedAt: Date?
    let goalType: String?
    let targetDate: Date?
    let notes: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case updatedAt = "updated_at"
      case goalText = "goal_text"
      case visualizationText = "visualization_text"
      case microAction = "micro_action"
      case status
      case completedAt = "completed_at"
      case goalType = "goal_type"
      case targetDate = "target_date"
      case notes
    }
  }

  // MARK: - Chat Conversations & Messages

  struct ChatConversation: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let updatedAt: Date?
    let title: String?
    let modelName: String?
    let isArchived: Bool?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case updatedAt = "updated_at"
      case title
      case modelName = "model_name"
      case isArchived = "is_archived"
    }
  }

  struct ChatMessageRecord: Codable {
    let id: UUID?
    let conversationId: UUID
    let userId: UUID
    let createdAt: Date?
    let role: String
    let content: String
    let tokensUsed: Int?
    let modelName: String?

    enum CodingKeys: String, CodingKey {
      case id
      case conversationId = "conversation_id"
      case userId = "user_id"
      case createdAt = "created_at"
      case role
      case content
      case tokensUsed = "tokens_used"
      case modelName = "model_name"
    }
  }

  /// Create a new chat conversation
  func createChatConversation(title: String? = nil, modelName: String = "gemini-2.5-flash") async throws -> ChatConversation {
    let userId = try await getCurrentUserId()

    let conversation = ChatConversation(
      id: nil,
      userId: userId,
      createdAt: nil,
      updatedAt: nil,
      title: title,
      modelName: modelName,
      isArchived: false
    )

    let response: PostgrestResponse<ChatConversation> =
      try await client
      .from("chat_conversations")
      .insert(conversation)
      .select()
      .single()
      .execute()

    print("âœ… Created chat conversation: \(response.value.id?.uuidString ?? "unknown")")
    return response.value
  }

  /// Save a chat message to an existing conversation
  func saveChatMessage(
    conversationId: UUID,
    role: String,
    content: String,
    modelName: String? = nil
  ) async throws -> ChatMessageRecord {
    let userId = try await getCurrentUserId()

    let message = ChatMessageRecord(
      id: nil,
      conversationId: conversationId,
      userId: userId,
      createdAt: nil,
      role: role,
      content: content,
      tokensUsed: nil,
      modelName: modelName
    )

    let response: PostgrestResponse<ChatMessageRecord> =
      try await client
      .from("chat_messages")
      .insert(message)
      .select()
      .single()
      .execute()

    return response.value
  }

  /// Fetch all conversations for the current user
  func fetchChatConversations(includeArchived: Bool = false) async throws -> [ChatConversation] {
    let userId = try await getCurrentUserId()

    var query = client
      .from("chat_conversations")
      .select()
      .eq("user_id", value: userId.uuidString)
      .order("updated_at", ascending: false)

    if !includeArchived {
      query = query.eq("is_archived", value: false)
    }

    let response: PostgrestResponse<[ChatConversation]> = try await query.execute()
    return response.value
  }

  /// Fetch messages for a specific conversation
  func fetchChatMessages(conversationId: UUID) async throws -> [ChatMessageRecord] {
    let response: PostgrestResponse<[ChatMessageRecord]> =
      try await client
      .from("chat_messages")
      .select()
      .eq("conversation_id", value: conversationId.uuidString)
      .order("created_at", ascending: true)
      .execute()

    return response.value
  }

  /// Update conversation title
  func updateConversationTitle(conversationId: UUID, title: String) async throws {
    struct TitleUpdate: Encodable {
      let title: String
    }

    try await client
      .from("chat_conversations")
      .update(TitleUpdate(title: title))
      .eq("id", value: conversationId.uuidString)
      .execute()
  }

  /// Archive a conversation
  func archiveConversation(conversationId: UUID) async throws {
    struct ArchiveUpdate: Encodable {
      let is_archived: Bool
    }

    try await client
      .from("chat_conversations")
      .update(ArchiveUpdate(is_archived: true))
      .eq("id", value: conversationId.uuidString)
      .execute()
  }

  // MARK: - User Notes (AI-generated insights)

  struct UserNote: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let updatedAt: Date?
    let category: String
    let content: String
    let sourceConversationId: UUID?
    let isActive: Bool?
    let importance: Int?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case updatedAt = "updated_at"
      case category
      case content
      case sourceConversationId = "source_conversation_id"
      case isActive = "is_active"
      case importance
    }
  }

  /// Fetch all active notes for the current user
  func fetchUserNotes(categories: [String]? = nil) async throws -> [UserNote] {
    let userId = try await getCurrentUserId()

    var query = client
      .from("user_notes")
      .select()
      .eq("user_id", value: userId.uuidString)
      .eq("is_active", value: true)
      .order("importance", ascending: false)
      .order("created_at", ascending: false)

    let response: PostgrestResponse<[UserNote]> = try await query.execute()
    
    // Filter by categories if specified
    if let categories = categories {
      return response.value.filter { categories.contains($0.category) }
    }
    return response.value
  }

  /// Save a new note about the user
  func saveUserNote(
    category: String,
    content: String,
    conversationId: UUID? = nil,
    importance: Int = 2
  ) async throws -> UserNote {
    let userId = try await getCurrentUserId()

    let note = UserNote(
      id: nil,
      userId: userId,
      createdAt: nil,
      updatedAt: nil,
      category: category,
      content: content,
      sourceConversationId: conversationId,
      isActive: true,
      importance: importance
    )

    let response: PostgrestResponse<UserNote> =
      try await client
      .from("user_notes")
      .insert(note)
      .select()
      .single()
      .execute()

    print("ðŸ“ Saved user note: [\(category)] \(content.prefix(50))...")
    return response.value
  }

  /// Deactivate a note (soft delete)
  func deactivateNote(noteId: UUID) async throws {
    struct DeactivateUpdate: Encodable {
      let is_active: Bool
    }

    try await client
      .from("user_notes")
      .update(DeactivateUpdate(is_active: false))
      .eq("id", value: noteId.uuidString)
      .execute()
  }

  /// Update note importance
  func updateNoteImportance(noteId: UUID, importance: Int) async throws {
    struct ImportanceUpdate: Encodable {
      let importance: Int
    }

    try await client
      .from("user_notes")
      .update(ImportanceUpdate(importance: min(5, max(1, importance))))
      .eq("id", value: noteId.uuidString)
      .execute()
  }

  // MARK: - Session Records

  struct SessionRecord: Codable {
    let id: UUID?
    let userId: UUID
    let createdAt: Date?
    let elevenLabsConversationId: String?
    let elevenLabsAgentId: String?

    enum CodingKeys: String, CodingKey {
      case id
      case userId = "user_id"
      case createdAt = "created_at"
      case elevenLabsConversationId = "elevenlabs_conversation_id"
      case elevenLabsAgentId = "elevenlabs_agent_id"
    }
  }

  /// Upload session audio into the sessions storage bucket and return the object path.
  func uploadSessionAudio(
    data: Data,
    userId: UUID,
    sessionId: UUID,
    fileExtension: String,
    mimeType: String
  ) async throws -> String {
    let normalizedExtension = fileExtension.trimmingCharacters(in: .whitespacesAndNewlines)
    let safeExtension = normalizedExtension.isEmpty ? "mp3" : normalizedExtension
    let userFolder = userId.uuidString.lowercased()
    let objectPath = "\(userFolder)/audio/\(sessionId.uuidString)/conversation.\(safeExtension)"

    do {
      _ = try await client.storage
        .from("sessions")
        .upload(
          objectPath,
          data: data,
          options: FileOptions(contentType: mimeType, upsert: false)
        )
      return objectPath
    } catch {
      print("âŒ Failed to upload session audio: \(error)")
      throw error
    }
  }

  /// Insert a new row into the public.sessions table so we can list archived sessions later.
  func insertSessionRecord(
    sessionId: UUID,
    userId: UUID,
    conversationId: String,
    agentId: String?
  ) async throws -> SessionRecord {
    let record = SessionRecord(
      id: sessionId,
      userId: userId,
      createdAt: nil,
      elevenLabsConversationId: conversationId,
      elevenLabsAgentId: agentId
    )

    do {
      let response: PostgrestResponse<SessionRecord> =
        try await client
        .from("sessions")
        .insert(record)
        .select()
        .single()
        .execute()
      return response.value
    } catch {
      print("âŒ Failed to insert session record: \(error)")
      throw error
    }
  }

  /// Fetch an existing session record by ElevenLabs conversation ID.
  func fetchSessionRecord(conversationId: String) async throws -> SessionRecord? {
    let response: PostgrestResponse<[SessionRecord]> =
      try await client
      .from("sessions")
      .select()
      .eq("elevenlabs_conversation_id", value: conversationId)
      .limit(1)
      .execute()

    return response.value.first
  }

  /// Create a new goal for the user
  func createGoal(
    goalText: String,
    visualizationText: String? = nil,
    microAction: String? = nil,
    goalType: String? = nil,
    targetDate: Date? = nil
  ) async throws -> Goal {
    let userId = try await getCurrentUserId()

    let goal = Goal(
      id: nil,
      userId: userId,
      createdAt: nil,
      updatedAt: nil,
      goalText: goalText,
      visualizationText: visualizationText,
      microAction: microAction,
      status: "active",
      completedAt: nil,
      goalType: goalType,
      targetDate: targetDate,
      notes: nil
    )

    let response: PostgrestResponse<Goal> =
      try await client
      .from("goals")
      .insert(goal)
      .select()
      .single()
      .execute()

    return response.value
  }

  /// Fetch all goals for the current user
  func fetchUserGoals() async throws -> [Goal] {
    let userId = try await getCurrentUserId()

    let response: PostgrestResponse<[Goal]> =
      try await client
      .from("goals")
      .select()
      .eq("user_id", value: userId.uuidString)
      .order("created_at", ascending: false)
      .execute()

    return response.value
  }

  // MARK: - Authentication Helpers

  /// Sign up a new user with email and password
  func signUp(email: String, password: String) async throws {
    try await client.auth.signUp(email: email, password: password)
  }

  /// Sign in an existing user
  func signIn(email: String, password: String) async throws {
    try await client.auth.signIn(email: email, password: password)
  }

  /// Sign in with Apple ID token
  func signInWithApple(idToken: String, nonce: String) async throws {
    try await client.auth.signInWithIdToken(credentials: .init(provider: .apple, idToken: idToken, nonce: nonce))
  }

  /// Sign out the current user
  func signOut() async throws {
    do {
      try await client.auth.signOut()
      print("âœ… Supabase sign out successful")
    } catch {
      print("âš ï¸ Sign out error (will clear session anyway): \(error)")
      // Even if sign out fails, we should clear the local session
      throw error
    }
  }

  /// Force clear all session data (debug only)
  func forceClearSession() {
    // Clear Supabase client session
    Task {
      try? await client.auth.signOut(scope: .local)
    }
    print("ðŸ”„ Force cleared local session")
  }

  /// Get the current authenticated user's ID
  func getCurrentUserId() async throws -> UUID {
    do {
      let session = try await client.auth.session
      print("ðŸ” Current session:")
      print("  - User ID: \(session.user.id)")
      print("  - Email: \(session.user.email ?? "no email")")
      print("  - Expired: \(session.isExpired)")

      guard !session.isExpired else {
        print("âŒ Session is expired")
        throw SupabaseError.authenticationRequired
      }
      guard let userId = UUID(uuidString: session.user.id.uuidString) else {
        print("âŒ Could not parse user ID: \(session.user.id.uuidString)")
        throw SupabaseError.authenticationRequired
      }
      return userId
    } catch {
      print("âŒ Failed to get current user: \(error)")
      throw SupabaseError.authenticationRequired
    }
  }

  /// Check if user is authenticated
  func isAuthenticated() async -> Bool {
    do {
      let session = try await client.auth.session
      return !session.isExpired
    } catch {
      return false
    }
  }
  
  /// Get the current user's first name from auth metadata (Sign In with Apple)
  func getCurrentUserFirstName() async -> String? {
    do {
      let session = try await client.auth.session
      let user = session.user
      
      // Try to get name from user metadata (set by Sign In with Apple)
      if case .string(let fullName) = user.userMetadata["full_name"], !fullName.isEmpty {
        // Extract first name from full name
        let firstName = fullName.components(separatedBy: " ").first ?? fullName
        return firstName
      }
      
      // Try alternative metadata keys
      if case .string(let name) = user.userMetadata["name"], !name.isEmpty {
        let firstName = name.components(separatedBy: " ").first ?? name
        return firstName
      }
      
      // Try first_name directly
      if case .string(let firstName) = user.userMetadata["first_name"], !firstName.isEmpty {
        return firstName
      }
      
      // Fallback to email prefix
      if let email = user.email {
        let emailPrefix = email.components(separatedBy: "@").first ?? ""
        if !emailPrefix.isEmpty {
          return emailPrefix.capitalized
        }
      }
      
      return nil
    } catch {
      print("âš ï¸ Could not get user first name: \(error)")
      return nil
    }
  }
  
  // MARK: - Debug Methods
  
  /// Test the Supabase connection (for debugging)
  func testConnection() async {
    print("ðŸ§ª [SupabaseManager] Testing connection...")
    print("   - URL: \(Config.supabaseURL)")
    
    do {
      // Try a simple health check endpoint
      let url = URL(string: "\(Config.supabaseURL)/rest/v1/")!
      print("   - Testing endpoint: \(url)")
      
      var request = URLRequest(url: url)
      request.httpMethod = "GET"
      request.setValue(Config.supabaseAnonKey, forHTTPHeaderField: "apikey")
      request.setValue("Bearer \(Config.supabaseAnonKey)", forHTTPHeaderField: "Authorization")
      
      let (data, response) = try await URLSession.shared.data(for: request)
      
      if let httpResponse = response as? HTTPURLResponse {
        print("   - Status code: \(httpResponse.statusCode)")
        print("   - Response headers: \(httpResponse.allHeaderFields)")
      }
      
      if let responseString = String(data: data, encoding: .utf8) {
        print("   - Response body: \(responseString.prefix(200))")
      }
      
      print("âœ… [SupabaseManager] Connection test successful")
    } catch {
      print("âŒ [SupabaseManager] Connection test failed:")
      print("   - Error: \(error)")
      print("   - Error type: \(type(of: error))")
      if let urlError = error as? URLError {
        print("   - URL Error code: \(urlError.code.rawValue)")
        print("   - URL Error description: \(urlError.localizedDescription)")
      }
    }
  }

  // MARK: - Helper Methods

  private func mapGoalRecencyToDatabase(_ recency: GoalRecency?) -> String? {
    switch recency {
    case .lastWeek:
      return "lastWeek"
    case .lastMonth:
      return "lastMonth"
    case .lastYear:
      return "lastYear"
    case .cantRemember:
      return "cantRemember"
    case nil:
      return nil
    }
  }

  private func mapCoachingStyleToDatabase(_ style: CoachingStyle?) -> String? {
    switch style {
    case .direct:
      return "direct"
    case .dataDriven:
      return "dataDriven"
    case .encouraging:
      return "encouraging"
    case .reflective:
      return "reflective"
    case nil:
      return nil
    }
  }
}

// MARK: - Custom Errors

enum SupabaseError: LocalizedError {
  case authenticationRequired
  case invalidConfiguration

  var errorDescription: String? {
    switch self {
    case .authenticationRequired:
      return "User must be authenticated to perform this action"
    case .invalidConfiguration:
      return "Supabase configuration is missing or invalid"
    }
  }
}
